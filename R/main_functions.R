# Main DBCAscatR functions

#' Creates a directory structure for inputs and outputs for a `DBCAscatR` workflow.
#'
#' \code{workspace} creates a directory structure for use with the `DBCAscatR`
#'     functions.
#'
#' @details When run within an `RStudio` project folder structure (highly
#'     recommended), it will create  `results/` and `source/` sub-directories.
#'     After running, the USER should place a copy of the raw data input csv file to the
#'     newly created `source/` sub-directory. All outputs from `DBCAscatR` functions
#'     will be written to the `results/` sub-directory.
#'
#' @return Two sub-directories, `results/` and `source/` will be created in the
#'     USERs `RStudio` project directory.
#'
#' @examples
#' \dontrun{
#' workspace()
#' }
#'
#' @author Bart Huntley, \email{bart.huntley@@dbca.wa.gov.au}
#'
#' For more details see  \url{https://dbca-wa.github.io/DBCAscatR/index.html}
#' {the DBCAscatR website}
#'
#' @import here
workspace <- function(){
  s <- here::here("source")
  r <- here::here("results")
  ifelse(!dir.exists(s),
         dir.create(s), FALSE)
  ifelse(!dir.exists(r),
         dir.create(r), FALSE)
}


#' Ingest of raw data and creation of two tidy data sets.
#'
#' \code{data_in} reads in raw data SNP genotype results file and creates two
#'     clean data sets, one with explicit NA's and the other with replacement
#'     blank cells.
#'
#' @details When run, it reads in a raw data csv file from the `source/` sub-directory
#'     performs some data cleaning and standardisation, and stores two data frames
#'     in a list. One data frame contains explicit NA's whilst the other has NA's
#'     coded as blank cells.
#'
#'     The raw data expected is SNP genotypes generated through the Agena
#'     Bioscience MassARRAY genotyping system.
#'
#' @param filename File name of raw data input csv as a character string.
#'
#' @param suffix File suffix to denote sample duplicates. Default is "_dup",
#'     change only if required.
#'
#' @return When assigned to an object it will create a list containing two data
#'     frames.
#'
#' @examples
#' \dontrun{
#' data_in(filename = "CAGRF20021407_raw.csv", suffix = "_dup")
#' }
#'
#' @author Bart Huntley, \email{bart.huntley@@dbca.wa.gov.au}
#'
#' For more details see  \url{https://dbca-wa.github.io/DBCAscatR/index.html}
#' {the DBCAscatR website}
#'
#' @import here
#' @importFrom readr read_csv
#' @importFrom janitor clean_names
#' @importFrom stringr str_detect
#' @import dplyr
#' @import tidyr
data_in <- function(filename, suffix = "_dup"){
  suppressWarnings({
    dat <- readr::read_csv(file, col_types = cols())
    # logic to catch misnamed replicate
    if(any(stringr::str_detect(dat[['X1']], suffix))){
      # data with NA
      file <- here::here("source", filename)
      na_dat <- readr::read_csv(file, na = "Fail", col_types = cols()) %>%
        janitor::clean_names() %>%
        dplyr::rename(sample = x1) %>%
        dplyr::mutate(rep = case_when(
          stringr::str_detect(sample, suffix) ~ 2,
          TRUE ~ 1),
          sample = gsub(suffix, "", sample),
          ind = stringr::str_detect(sample, "Blank")) %>%
        dplyr::filter(ind != TRUE) %>%
        dplyr::select(sample, rep, everything(), -ind)

      # data with blanks for NA
      all_dat <- read_csv(file, col_types = cols()) %>%
        janitor::clean_names() %>%
        dplyr::rename(sample = x1) %>%
        dplyr::mutate(rep = case_when(
          stringr::str_detect(sample, suffix) ~ 2,
          TRUE ~ 1),
          sample = gsub(suffix, "", sample),
          ind = stringr::str_detect(sample, "Blank")) %>%
        dplyr::filter(ind != TRUE) %>%
        dplyr::select(sample, rep, everything(), -ind) %>%
        tidyr::pivot_longer(cols = starts_with("x"),
                            names_to = "marker",
                            values_to = "val") %>%
        dplyr::mutate(val = ifelse(val == "Fail", "", val)) %>%
        tidyr::pivot_wider(names_from = marker,
                           values_from = val)

      out <- list(na_dat = na_dat, all_dat = all_dat)
      return(out)
    } else{
      stop("The suffix chosen is not present in the raw data")
    }

  })
}

#' Calculates genetic errors
#'
#' \code{main_errors} takes the list generated by \code{\link{data_in}} and
#'     generates genetic error outputs which are written to csv file.
#'
#' @details When run it calculates genetic errors on the complete raw data set
#'     which it receives in the form of a list from the \code{\link{data_in}}
#'     function. Outputs are written to csv file to the `results/` sub-directory.
#'     \itemize{
#'         \item numerical_alleles.csv
#'         \item sample_error_results.csv
#'         \item summary_error_results.csv}
#'
#'      These outputs are used in downstream processes and are further refined.
#'
#' @param dl data list. This is a list containing two data frames as output from
#'     the \code{\link{data_in}} function.
#'
#' @return It will write to csv file genetic error file csv's for further
#'     processing and/or evaluation.
#'
#' @examples
#' \dontrun{
#' main_errors(dl)
#' }
#'
#' @author Bart Huntley, \email{bart.huntley@@dbca.wa.gov.au}
#'
#' For more details see  \url{https://dbca-wa.github.io/DBCAscatR/index.html}
#' {the DBCAscatR website}
#'
#' @import dplyr
#' @importFrom tibble tibble
#' @importFrom readr write_csv
#' @import tidyr
main_errors <- function(dl){
  suppressWarnings({
    na_dat <- dl[['na_dat']]
    all_dat <- dl[['all_dat']]
    # just variables
    df_loci <- na_dat  %>%
      dplyr::select(starts_with("X")) # keep loci columns for calcs

    # clean with blanks
    cl_dat_bl <- all_dat[rowSums(is.na(df_loci)) != ncol(df_loci),]

    # clean with na's
    cl_dat_na <- na_dat[rowSums(is.na(df_loci)) != ncol(df_loci),]

    # anonymous function for merge alleles for grouping step
    f1 <- function(x){trimws(paste(x, collapse = ''))}

    # set up for loop variables stuff to use in loop
    lgth_vars <- dim(df_loci)[2]
    u_samp <- unique(unlist(cl_dat_bl[, 1]))
    samp_names <- paste0("s", u_samp)

    # set up data frames to hold results
    results_out <- tibble::tibble()
    num_out <- tibble::tibble()

    # loop and calculate interim and end results
    for(i in seq_along(u_samp)){
      # using na data
      avg_amp_rate <- cl_dat_na %>%
        dplyr::filter(sample == u_samp[i]) %>%
        tidyr::pivot_longer(cols = starts_with("x"),
                            names_to = "vars",
                            values_to = "vals") %>%
        dplyr::group_by(rep) %>%
        dplyr::summarise(amp_rate = sum(!is.na(vals))/lgth_vars) %>%
        dplyr::summarise(avg_amp_rate = mean(amp_rate))

      # interim data (creating new variables to calculate errors)
      d <- cl_dat_bl %>%
        dplyr::filter(sample == u_samp[i]) %>%
        dplyr::group_by(sample) %>%
        dplyr::summarise_all(.funs = f1) %>%
        dplyr::ungroup() %>%
        tidyr::pivot_longer(cols = starts_with("x"),
                            names_to = "vars",
                            values_to = "vals") %>%
        dplyr::mutate(
          f = case_when(
            nchar(vals) == 4 ~ vals,
            TRUE ~ ""),
          c = nchar(f),
          loc_err = ifelse(c == 4 & substr(f, 1, 2) != substr(f, 3, 4),
                           0.5, 0),
          p1 = substr(f, 1, 1),
          p2 = substr(f, 2 ,2),
          p3 = substr(f, 3, 3),
          p4 = substr(f, 4 ,4),
          a_mm1 = ifelse(c == 4 & p1 != p3, 1, 0),
          a_mm2 = ifelse(c == 4 & p2 != p4, 1, 0),
          a_err = (a_mm1 + a_mm2)/4,
          het_only = case_when(
            p1 == p2 & p3 == p4 ~ 0,
            TRUE ~ 1),
          a_drop = case_when(
            het_only == 1 & substr(f, 1, 2) != substr(f, 3, 4) ~ 0.5,
            TRUE ~ 0),
          fa = case_when(
            c == 4 & het_only == 0 & substr(f, 1 ,2) != substr(f, 3 ,4) ~ 0.5,
            TRUE ~ 0))

      # take interim data and use to convert to numerical values for export
      num_vals <- d %>%
        dplyr::mutate(new_var = case_when(
          nchar(vals) == 2 ~ substr(vals, 1, 2),
          nchar(vals) == 4 & substr(vals, 1, 2) == substr(vals, 3, 4) ~ substr(vals, 1, 2),
          TRUE ~ "NA"
        )) %>%
        dplyr::mutate(to_recode = case_when(
          new_var == "NA" ~ 0,
          TRUE ~ 1
        ),
        a1 = ifelse(to_recode == 1, substr(vals, 1, 1), NA),
        b1 = ifelse(to_recode == 1, substr(vals, 2, 2), NA),
        a = case_when(
          a1 == "A" ~ 110,
          a1 == "T" ~ 120,
          a1 == "G" ~ 130,
          a1 == "C" ~ 140
        ),
        b = case_when(
          b1 == "A" ~ 110,
          b1 == "T" ~ 120,
          b1 == "G" ~ 130,
          b1 == "C" ~ 140)
        ) %>%
        dplyr::select(sample, vars, a, b) %>%
        tidyr::pivot_longer(cols = c("a", "b"),
                            names_to = "locus",
                            values_to = "value") %>%
        dplyr::arrange(vars, locus) %>%
        tidyr::pivot_wider(names_from = c(vars, locus), values_from = value)

      # take interim data and calculate errors for export
      results <- d %>%
        dplyr::summarise(locus_error = sum(loc_err)/sum(c == 4),
                         allele_error = sum(a_err)/sum(c == 4),
                         allelic_drop_out = sum(a_drop)/sum(het_only),
                         false_allele = sum(fa)/(sum(c)/4)) %>%
        dplyr::bind_cols(avg_amp_rate) %>%
        dplyr::mutate(sample = samp_names[i]) %>%
        dplyr::select(sample, avg_amp_rate, allele_error, locus_error, allelic_drop_out,
                      false_allele)

      # bind exports to appropriate result data frames
      results_out <- dplyr::bind_rows(results_out, results)
      num_out <- dplyr::bind_rows(num_out, num_vals)
    }

    # take the error results and further summarise
    summaries <- results_out %>%
      tidyr::pivot_longer(cols = -sample,
                          names_to = "error",
                          values_to = "value") %>%
      dplyr::group_by(error) %>%
      dplyr::summarise(avg = mean(value, na.rm = TRUE),
                       se = sd(value, na.rm = TRUE)/sqrt(n()))

    # write to file errors per sample
    readr::write_csv(results_out, here::here("results", "sample_error_results.csv"))

    # write to file summary errors for whole of data run
    readr::write_csv(summaries, here::here("results", "summary_error_results.csv"))

    # write to file numerical version
    readr::write_csv(num_out, here::here("results", "numerical_alleles.csv"))
  })
}
